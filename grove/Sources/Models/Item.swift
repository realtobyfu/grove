import Foundation
import SwiftData

// MARK: - Growth Stage

enum GrowthStage: String, CaseIterable, Sendable {
    case seed
    case sprout
    case sapling
    case tree

    var displayName: String {
        switch self {
        case .seed: "Seed"
        case .sprout: "Sprout"
        case .sapling: "Sapling"
        case .tree: "Tree"
        }
    }

    var systemImage: String {
        switch self {
        case .seed: "leaf"
        case .sprout: "leaf.fill"
        case .sapling: "leaf.fill"
        case .tree: "tree.fill"
        }
    }

    var iconSize: CGFloat {
        switch self {
        case .seed: 8
        case .sprout: 10
        case .sapling: 12
        case .tree: 14
        }
    }

    var colorHex: String {
        switch self {
        case .seed: "BBBBBB"     // text.muted
        case .sprout: "AAAAAA"   // text.tertiary
        case .sapling: "777777"  // text.secondary
        case .tree: "1A1A1A"     // text.primary
        }
    }

    var darkColorHex: String {
        switch self {
        case .seed: "444444"     // text.muted (dark)
        case .sprout: "555555"   // text.tertiary (dark)
        case .sapling: "888888"  // text.secondary (dark)
        case .tree: "E8E8E8"     // text.primary (dark)
        }
    }

    init(score: Int) {
        switch score {
        case 0...10: self = .seed
        case 11...30: self = .sprout
        case 31...60: self = .sapling
        default: self = .tree
        }
    }
}

enum ItemType: String, Codable {
    case article
    case video
    case note
    case courseLecture

    var iconName: String {
        switch self {
        case .article: "doc.richtext"
        case .video: "play.rectangle"
        case .note: "note.text"
        case .courseLecture: "graduationcap"
        }
    }
}

enum ItemStatus: String, Codable {
    case inbox
    case queued
    case active
    case archived
    case dismissed
}

@Model
final class Item {
    var id: UUID
    var title: String
    var type: ItemType
    var status: ItemStatus
    var sourceURL: String?
    var content: String?
    var thumbnail: Data?
    var engagementScore: Float
    var metadata: [String: String]
    var createdAt: Date
    var updatedAt: Date

    // Inbox defer queue ("Read Later")
    var readLaterUntil: Date?

    // Spaced resurfacing fields
    var lastResurfacedAt: Date?
    var resurfaceIntervalDays: Int = 7
    var resurfaceCount: Int = 0
    var lastEngagedAt: Date?
    var isResurfacingPaused: Bool = false

    @Relationship(inverse: \Board.items) var boards: [Board]
    @Relationship(inverse: \Tag.items) var tags: [Tag]
    @Relationship(deleteRule: .cascade, inverse: \Annotation.item) var annotations: [Annotation]
    @Relationship(deleteRule: .cascade, inverse: \ReflectionBlock.item) var reflections: [ReflectionBlock]
    @Relationship(deleteRule: .cascade, inverse: \Connection.sourceItem) var outgoingConnections: [Connection]
    @Relationship(deleteRule: .cascade, inverse: \Connection.targetItem) var incomingConnections: [Connection]

    // MARK: - Depth Score & Growth Stage

    /// Computed depth score based on engagement activities.
    /// opened=5, manually_tagged=5, reflected=25, connected=15 each,
    /// referenced_in_synthesis=20, revisited_after_7days=10
    var depthScore: Int {
        var score = 0

        // opened: item moved out of inbox = 5pts
        if status != .inbox && status != .queued {
            score += 5
        }

        // manually_tagged: has at least one non-auto tag = 5pts
        let manualTags = tags.filter { !$0.isAutoGenerated }
        if !manualTags.isEmpty {
            score += 5
        }

        // reflected: 25pts per reflection block
        score += reflections.count * 25

        // connected: 15pts per connection (outgoing + incoming)
        score += (outgoingConnections.count + incomingConnections.count) * 15

        // referenced_in_synthesis: item was referenced in an AI synthesis note = 20pts
        if metadata["referencedInSynthesis"] == "true" {
            score += 20
        }

        // revisited_after_7days: item was engaged after 7+ days from creation = 10pts
        if let lastEngaged = lastEngagedAt {
            let daysSinceCreation = Calendar.current.dateComponents([.day], from: createdAt, to: lastEngaged).day ?? 0
            if daysSinceCreation >= 7 {
                score += 10
            }
        }

        return score
    }

    /// Growth stage derived from depth score.
    var growthStage: GrowthStage {
        GrowthStage(score: depthScore)
    }

    /// Breakdown of the depth score for tooltip display.
    var scoreBreakdown: [(label: String, points: Int)] {
        var breakdown: [(label: String, points: Int)] = []

        if status != .inbox && status != .queued {
            breakdown.append(("Opened", 5))
        }

        let manualTags = tags.filter { !$0.isAutoGenerated }
        if !manualTags.isEmpty {
            breakdown.append(("Tagged", 5))
        }

        if reflections.count > 0 {
            breakdown.append(("Reflections ×\(reflections.count)", reflections.count * 25))
        }

        let connectionCount = outgoingConnections.count + incomingConnections.count
        if connectionCount > 0 {
            breakdown.append(("Connections ×\(connectionCount)", connectionCount * 15))
        }

        if metadata["referencedInSynthesis"] == "true" {
            breakdown.append(("In Synthesis", 20))
        }

        if let lastEngaged = lastEngagedAt {
            let daysSinceCreation = Calendar.current.dateComponents([.day], from: createdAt, to: lastEngaged).day ?? 0
            if daysSinceCreation >= 7 {
                breakdown.append(("Revisited", 10))
            }
        }

        return breakdown
    }

    /// Whether this item is eligible for the resurfacing queue.
    /// Requires at least one reflection or connection.
    var isResurfacingEligible: Bool {
        !reflections.isEmpty || !outgoingConnections.isEmpty || !incomingConnections.isEmpty
    }

    /// Whether this item is deferred from inbox triage until a future date.
    var isQueuedForReadLater: Bool {
        guard status == .queued, let until = readLaterUntil else { return false }
        return until > .now
    }

    /// Next resurfacing date based on lastResurfacedAt + interval, or lastEngagedAt + interval.
    var nextResurfaceDate: Date? {
        guard isResurfacingEligible, !isResurfacingPaused, status == .active else { return nil }
        let referenceDate = lastResurfacedAt ?? lastEngagedAt ?? createdAt
        return Calendar.current.date(byAdding: .day, value: resurfaceIntervalDays, to: referenceDate)
    }

    /// Whether this item is overdue for resurfacing.
    var isResurfacingOverdue: Bool {
        guard let nextDate = nextResurfaceDate else { return false }
        return nextDate <= .now
    }

    init(title: String, type: ItemType) {
        self.id = UUID()
        self.title = title
        self.type = type
        self.status = .inbox
        self.sourceURL = nil
        self.content = nil
        self.thumbnail = nil
        self.engagementScore = 0
        self.metadata = [:]
        self.createdAt = .now
        self.updatedAt = .now
        self.readLaterUntil = nil
        self.lastResurfacedAt = nil
        self.resurfaceIntervalDays = 7
        self.resurfaceCount = 0
        self.lastEngagedAt = nil
        self.isResurfacingPaused = false
        self.boards = []
        self.tags = []
        self.annotations = []
        self.reflections = []
        self.outgoingConnections = []
        self.incomingConnections = []
    }
}
