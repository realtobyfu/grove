import Foundation
import SwiftData

extension Notification.Name {
    /// Posted after auto-tagging when a new board should be suggested to the user.
    /// userInfo keys:
    /// - "itemID" (UUID)
    /// - "boardName" (String)
    /// - "isColdStart" (Bool)
    /// - "mode" (String: existing/create)
    /// - "boardID" (String UUID, optional)
    /// - "confidence" (Double)
    /// - "reason" (String, optional)
    /// - "alternatives" (comma-separated UUID list, optional)
    static let groveNewBoardSuggestion = Notification.Name("groveNewBoardSuggestion")
}

/// Response shape expected from the LLM for auto-tagging.
private struct AutoTagResponse: Decodable {
    struct TagEntry: Decodable {
        let name: String
        let category: String?
        let confidence: Double?
    }

    let tags: [TagEntry]
    let one_line_summary: String?
    let suggested_board: String?
}

/// Protocol for auto-tagging items via LLM.
protocol AutoTagServiceProtocol {
    @MainActor func tagItem(_ item: Item, in context: ModelContext) async
}

/// Generates tags, a one-line summary, and a suggested board for an Item using the LLM.
/// Gracefully degrades — if the LLM is unavailable or returns bad data,
/// the item is left unchanged.
final class AutoTagService: AutoTagServiceProtocol {
    private let provider: LLMProvider

    init(provider: LLMProvider = LLMServiceConfig.makeProvider()) {
        self.provider = provider
    }

    @MainActor func tagItem(_ item: Item, in context: ModelContext) async {
        guard LLMServiceConfig.isConfigured else { return }
        guard EntitlementService.shared.canUse(.autoTagging) else { return }

        // Gather existing board names to help the LLM suggest one
        let boardDescriptor = FetchDescriptor<Board>()
        let boardNames = (try? context.fetch(boardDescriptor))?.map(\.title) ?? []
        let boardList = boardNames.isEmpty ? "none" : boardNames.joined(separator: ", ")

        let systemPrompt = """
        You are a knowledge-management assistant. Given an item's title, source URL, and content excerpt, \
        return a JSON object with:
        - "tags": an array of objects, each with "name" (lowercase, 1-3 words), \
          "category" (one of: topic, concept, technology, person, custom), and \
          "confidence" (0.0-1.0).
        - "one_line_summary": a single sentence summarizing the item (max 120 characters). \
          This field is REQUIRED — always return a summary even if content is minimal. \
          Use the title and URL to infer the topic if needed.
        - "suggested_board": the best board name for this item. Prefer an existing board if one fits. \
          If none fit, suggest a concise, reusable topic name (2-4 words) that could group related items. \
          Avoid one-off labels; think in terms of durable categories.
        Return 3-7 tags. Only return valid JSON, no extra text.
        """

        let contentExcerpt = String((item.content ?? "").prefix(1500))
        let userPrompt = """
        Title: \(item.title)
        Source URL: \(item.sourceURL ?? "none")
        Content:
        \(contentExcerpt)

        Existing boards: \(boardList)
        """

        guard let result = await provider.complete(system: systemPrompt, user: userPrompt, service: "tagging") else {
            return
        }

        guard let parsed = LLMJSONParser.decode(AutoTagResponse.self, from: result.content) else {
            return
        }

        // Apply tags
        for entry in parsed.tags {
            let tagName = entry.name.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
            guard !tagName.isEmpty else { continue }

            let confidence = Float(min(max(entry.confidence ?? 0.5, 0), 1))
            let category = TagCategory(rawValue: entry.category ?? "custom") ?? .custom

            // Reuse existing tag with the same name if one exists
            let descriptor = FetchDescriptor<Tag>(predicate: #Predicate { $0.name == tagName })
            let existing = (try? context.fetch(descriptor))?.first

            if let existing {
                if !item.tags.contains(where: { $0.id == existing.id }) {
                    item.tags.append(existing)
                }
            } else {
                let tag = Tag(name: tagName, category: category, isAutoGenerated: true, confidence: confidence)
                context.insert(tag)
                item.tags.append(tag)
            }
        }

        EntitlementService.shared.recordUse(.autoTagging)

        // Apply one-line summary
        if let summary = parsed.one_line_summary, !summary.isEmpty {
            item.metadata["summary"] = String(summary.prefix(120))
        }

        let connectionService = ConnectionSuggestionService(modelContext: context)

        // Apply suggested board
        if let suggestedBoard = parsed.suggested_board, !suggestedBoard.isEmpty {
            let boardDescriptorAll = FetchDescriptor<Board>()
            let allBoards = (try? context.fetch(boardDescriptorAll)) ?? []
            let isColdStart = allBoards.isEmpty

            let suggestionEngine = BoardSuggestionEngine()
            let decision = suggestionEngine.resolveSuggestion(
                for: item,
                suggestedName: suggestedBoard,
                boards: allBoards
            )
            BoardSuggestionMetadata.apply(decision, to: item)
            try? context.save()

            NotificationCenter.default.post(
                name: .groveNewBoardSuggestion,
                object: nil,
                userInfo: BoardSuggestionMetadata.notificationUserInfo(
                    itemID: item.id,
                    decision: decision,
                    isColdStart: isColdStart
                )
            )

            // Auto-connect: find and persist high-confidence links to existing items
            await connectionService.autoConnect(item: item, in: context)
            return
        }

        try? context.save()

        // Auto-connect: find and persist high-confidence links to existing items
        await connectionService.autoConnect(item: item, in: context)
    }
}
