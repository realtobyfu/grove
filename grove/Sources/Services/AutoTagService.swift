import Foundation
import SwiftData

/// Response shape expected from the LLM for auto-tagging.
private struct AutoTagResponse: Decodable {
    struct TagEntry: Decodable {
        let name: String
        let category: String?
        let confidence: Double?
    }

    let tags: [TagEntry]
    let one_line_summary: String?
    let suggested_board: String?
}

/// Protocol for auto-tagging items via LLM.
@MainActor
protocol AutoTagServiceProtocol {
    func tagItem(_ item: Item, in context: ModelContext) async
}

/// Generates tags, a one-line summary, and a suggested board for an Item using the LLM.
/// Gracefully degrades — if the LLM is unavailable or returns bad data,
/// the item is left unchanged.
@MainActor
final class AutoTagService: AutoTagServiceProtocol {
    private let provider: LLMProvider

    init(provider: LLMProvider = GroqProvider()) {
        self.provider = provider
    }

    func tagItem(_ item: Item, in context: ModelContext) async {
        guard LLMServiceConfig.isConfigured else { return }

        // Gather existing board names to help the LLM suggest one
        let boardDescriptor = FetchDescriptor<Board>()
        let boardNames = (try? context.fetch(boardDescriptor))?.map(\.title) ?? []
        let boardList = boardNames.isEmpty ? "none" : boardNames.joined(separator: ", ")

        let systemPrompt = """
        You are a knowledge-management assistant. Given an item's title, source URL, and content excerpt, \
        return a JSON object with:
        - "tags": an array of objects, each with "name" (lowercase, 1-3 words), \
          "category" (one of: topic, concept, technology, person, custom), and \
          "confidence" (0.0-1.0).
        - "one_line_summary": a single sentence summarizing the item (max 120 characters). \
          This field is REQUIRED — always return a summary even if content is minimal. \
          Use the title and URL to infer the topic if needed.
        - "suggested_board": the best board name for this item. Prefer an existing board if one fits. \
          If none fit, suggest a concise, reusable topic name (2-4 words) that could group related items. \
          Avoid one-off labels; think in terms of durable categories.
        Return 3-7 tags. Only return valid JSON, no extra text.
        """

        let contentExcerpt = String((item.content ?? "").prefix(1500))
        let userPrompt = """
        Title: \(item.title)
        Source URL: \(item.sourceURL ?? "none")
        Content:
        \(contentExcerpt)

        Existing boards: \(boardList)
        """

        guard let result = await provider.complete(system: systemPrompt, user: userPrompt, service: "tagging") else {
            return
        }

        guard let parsed = LLMJSONParser.decode(AutoTagResponse.self, from: result.content) else {
            return
        }

        // Apply tags
        for entry in parsed.tags {
            let tagName = entry.name.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
            guard !tagName.isEmpty else { continue }

            let confidence = Float(min(max(entry.confidence ?? 0.5, 0), 1))
            let category = TagCategory(rawValue: entry.category ?? "custom") ?? .custom

            // Reuse existing tag with the same name if one exists
            let descriptor = FetchDescriptor<Tag>(predicate: #Predicate { $0.name == tagName })
            let existing = (try? context.fetch(descriptor))?.first

            if let existing {
                if !item.tags.contains(where: { $0.id == existing.id }) {
                    item.tags.append(existing)
                }
            } else {
                let tag = Tag(name: tagName, category: category, isAutoGenerated: true, confidence: confidence)
                context.insert(tag)
                item.tags.append(tag)
            }
        }

        // Apply one-line summary
        if let summary = parsed.one_line_summary, !summary.isEmpty {
            item.metadata["summary"] = String(summary.prefix(120))
        }

        // Apply suggested board — auto-create if it doesn't exist
        if let suggestedBoard = parsed.suggested_board, !suggestedBoard.isEmpty {
            item.metadata["suggestedBoard"] = suggestedBoard

            let boardDescriptorAll = FetchDescriptor<Board>()
            let allBoards = (try? context.fetch(boardDescriptorAll)) ?? []
            let matchedBoard = allBoards.first(where: {
                $0.title.localizedCaseInsensitiveCompare(suggestedBoard) == .orderedSame
            })

            if let board = matchedBoard {
                // Existing board — assign directly
                if !item.boards.contains(where: { $0.id == board.id }) {
                    item.boards.append(board)
                }
            } else {
                // No match — create a new board and assign
                let newBoard = Board(title: suggestedBoard)
                context.insert(newBoard)
                item.boards.append(newBoard)
            }
        }

        try? context.save()
    }
}
