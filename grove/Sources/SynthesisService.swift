import Foundation
import SwiftData

/// Configuration for how synthesis should be generated.
enum SynthesisProvider: String, Codable, CaseIterable, Sendable {
    case local = "Local (Keyword Extraction)"
    case api = "API (OpenAI-compatible)"
}

/// Stores user preferences for AI synthesis in UserDefaults.
struct SynthesisSettings {
    private static let providerKey = "grove.synthesis.provider"
    private static let apiEndpointKey = "grove.synthesis.apiEndpoint"
    private static let apiKeyKey = "grove.synthesis.apiKey"
    private static let apiModelKey = "grove.synthesis.apiModel"

    static var provider: SynthesisProvider {
        get {
            guard let raw = UserDefaults.standard.string(forKey: providerKey),
                  let value = SynthesisProvider(rawValue: raw) else { return .local }
            return value
        }
        set { UserDefaults.standard.set(newValue.rawValue, forKey: providerKey) }
    }

    static var apiEndpoint: String {
        get { UserDefaults.standard.string(forKey: apiEndpointKey) ?? "https://api.openai.com/v1/chat/completions" }
        set { UserDefaults.standard.set(newValue, forKey: apiEndpointKey) }
    }

    static var apiKey: String {
        get { UserDefaults.standard.string(forKey: apiKeyKey) ?? "" }
        set { UserDefaults.standard.set(newValue, forKey: apiKeyKey) }
    }

    static var apiModel: String {
        get { UserDefaults.standard.string(forKey: apiModelKey) ?? "gpt-4o-mini" }
        set { UserDefaults.standard.set(newValue, forKey: apiModelKey) }
    }
}

/// Result of a synthesis generation.
struct SynthesisResult: Sendable {
    let markdownContent: String
    let sourceItemIDs: [UUID]
    let provider: SynthesisProvider
}

/// Service that generates AI synthesis notes from a collection of items.
@MainActor
@Observable
final class SynthesisService {
    private let modelContext: ModelContext
    var isGenerating = false
    var progress: String = ""
    var lastError: String?

    init(modelContext: ModelContext) {
        self.modelContext = modelContext
    }

    /// Validate whether synthesis can be performed on the given items.
    /// Returns nil if valid, or an error message if not.
    func validateScope(items: [Item]) -> String? {
        if items.isEmpty {
            return "No items to synthesize."
        }
        if items.count < 2 {
            return "Need at least 2 items for synthesis."
        }
        if items.count > 30 {
            return "Too many items (\(items.count)). Synthesis works best with 3â€“15 items. Please narrow your scope."
        }
        if items.count > 15 {
            return nil // Allow but we'll show a warning in the UI
        }
        return nil
    }

    /// Generate a synthesis note from the given items.
    func generateSynthesis(items: [Item], scopeTitle: String) async -> SynthesisResult? {
        isGenerating = true
        progress = "Collecting content..."
        lastError = nil

        let provider = SynthesisSettings.provider

        let result: SynthesisResult?
        switch provider {
        case .local:
            result = await generateLocalSynthesis(items: items, scopeTitle: scopeTitle)
        case .api:
            result = await generateAPISynthesis(items: items, scopeTitle: scopeTitle)
        }

        isGenerating = false
        progress = ""

        return result
    }

    /// Create a synthesis Item from the result, link it to source items via Connections.
    func createSynthesisItem(from result: SynthesisResult, title: String, inBoard: Board?) -> Item {
        let item = Item(title: title, type: .note)
        item.status = .active
        item.content = result.markdownContent
        item.metadata["isAIGenerated"] = "true"
        item.metadata["synthesisProvider"] = result.provider.rawValue
        item.metadata["synthesisDate"] = ISO8601DateFormatter().string(from: Date())
        item.metadata["sourceItemCount"] = "\(result.sourceItemIDs.count)"
        modelContext.insert(item)

        // Link to source items
        let descriptor = FetchDescriptor<Item>()
        let allItems = (try? modelContext.fetch(descriptor)) ?? []
        for sourceID in result.sourceItemIDs {
            if let sourceItem = allItems.first(where: { $0.id == sourceID }) {
                let connection = Connection(sourceItem: sourceItem, targetItem: item, type: .related)
                connection.isAutoGenerated = true
                connection.note = "Source for synthesis note"
                modelContext.insert(connection)
                sourceItem.outgoingConnections.append(connection)
                item.incomingConnections.append(connection)
            }
        }

        // Assign to board if provided
        if let board = inBoard, !board.isSmart {
            item.boards.append(board)
        }

        // Copy common tags from source items to synthesis note
        let tagCounts = countTags(items: allItems.filter { result.sourceItemIDs.contains($0.id) })
        let commonTags = tagCounts.filter { $0.count >= 2 }.sorted { $0.count > $1.count }.prefix(5)
        for (tag, _) in commonTags {
            if !item.tags.contains(where: { $0.id == tag.id }) {
                item.tags.append(tag)
            }
        }

        try? modelContext.save()
        return item
    }

    // MARK: - Local Synthesis (Heuristic)

    private func generateLocalSynthesis(items: [Item], scopeTitle: String) async -> SynthesisResult? {
        progress = "Analyzing \(items.count) items..."

        // Extract content from each item
        let itemSummaries = items.map { item -> (item: Item, keywords: Set<String>, contentPreview: String) in
            let text = [item.title, item.content ?? ""].joined(separator: " ")
            let keywords = extractKeywords(from: text)
            let preview = (item.content ?? "").prefix(300)
            return (item, keywords, String(preview))
        }

        // Gather all annotations
        let allAnnotations = items.flatMap { $0.annotations }

        progress = "Finding themes..."

        // Find key themes (frequent keywords across items)
        var keywordFrequency: [String: Int] = [:]
        for summary in itemSummaries {
            for keyword in summary.keywords {
                keywordFrequency[keyword, default: 0] += 1
            }
        }
        let themes = keywordFrequency
            .filter { $0.value >= 2 }
            .sorted { $0.value > $1.value }
            .prefix(8)
            .map { $0.key }

        // Detect shared tags
        let tagCounts = countTags(items: items)
        let commonTags = tagCounts.filter { $0.count >= 2 }.sorted { $0.count > $1.count }

        progress = "Finding contradictions..."

        // Look for contradictions (items connected via .contradicts)
        var contradictions: [(Item, Item)] = []
        for item in items {
            for conn in item.outgoingConnections where conn.type == .contradicts {
                if let target = conn.targetItem, items.contains(where: { $0.id == target.id }) {
                    contradictions.append((item, target))
                }
            }
        }

        // Look for buildsOn chains
        var buildChains: [(from: Item, to: Item)] = []
        for item in items {
            for conn in item.outgoingConnections where conn.type == .buildsOn {
                if let target = conn.targetItem, items.contains(where: { $0.id == target.id }) {
                    buildChains.append((item, target))
                }
            }
        }

        progress = "Generating synthesis..."

        // Build markdown
        var md = "# Synthesis: \(scopeTitle)\n\n"
        md += "> *AI-generated synthesis of \(items.count) items.*\n\n"

        // Key Themes
        md += "## Key Themes\n\n"
        if themes.isEmpty {
            md += "No strong recurring themes detected across these items.\n\n"
        } else {
            for theme in themes {
                let relatedItems = itemSummaries.filter { $0.keywords.contains(theme) }
                let itemTitles = relatedItems.prefix(3).map { "**\($0.item.title)**" }.joined(separator: ", ")
                md += "- **\(theme.capitalized)** â€” appears across \(relatedItems.count) items: \(itemTitles)\n"
            }
            md += "\n"
        }

        // Common tags
        if !commonTags.isEmpty {
            md += "## Shared Topics\n\n"
            for (tag, count) in commonTags.prefix(5) {
                md += "- **\(tag.name)** (\(tag.category.displayName)) â€” \(count) items\n"
            }
            md += "\n"
        }

        // Source overview
        md += "## Sources\n\n"
        for item in items.sorted(by: { $0.createdAt < $1.createdAt }) {
            let typeIcon: String
            switch item.type {
            case .article: typeIcon = "ðŸ“„"
            case .video: typeIcon = "ðŸŽ¬"
            case .note: typeIcon = "ðŸ“"
            case .courseLecture: typeIcon = "ðŸŽ“"
            }
            md += "### \(typeIcon) \(item.title)\n\n"
            if let url = item.sourceURL, !url.isEmpty {
                md += "Source: \(url)\n\n"
            }
            if let content = item.content, !content.isEmpty {
                let trimmed = String(content.prefix(200))
                md += "\(trimmed)\(content.count > 200 ? "..." : "")\n\n"
            }
            // Include annotations
            let itemAnnotations = allAnnotations.filter { $0.item?.id == item.id }
            if !itemAnnotations.isEmpty {
                md += "**Your notes:**\n"
                for annotation in itemAnnotations.prefix(3) {
                    let annotationPreview = String(annotation.content.prefix(150))
                    md += "- \(annotationPreview)\(annotation.content.count > 150 ? "..." : "")\n"
                }
                md += "\n"
            }
        }

        // Contradictions
        if !contradictions.isEmpty {
            md += "## Contradictions\n\n"
            for (a, b) in contradictions {
                md += "- **\(a.title)** contradicts **\(b.title)**\n"
            }
            md += "\n"
        }

        // Build chains
        if !buildChains.isEmpty {
            md += "## Progression\n\n"
            for chain in buildChains {
                md += "- **\(chain.from.title)** builds on **\(chain.to.title)**\n"
            }
            md += "\n"
        }

        // Open Questions
        md += "## Open Questions\n\n"
        md += "- What are the practical implications of these combined insights?\n"
        if contradictions.isEmpty {
            md += "- Are there any tensions or disagreements between these sources that aren't explicitly connected?\n"
        }
        md += "- What related topics should be explored next?\n"
        md += "\n"

        md += "---\n*Generated locally on \(Date().formatted(date: .abbreviated, time: .shortened))*\n"

        return SynthesisResult(
            markdownContent: md,
            sourceItemIDs: items.map(\.id),
            provider: .local
        )
    }

    // MARK: - API Synthesis

    private func generateAPISynthesis(items: [Item], scopeTitle: String) async -> SynthesisResult? {
        let endpoint = SynthesisSettings.apiEndpoint
        let apiKey = SynthesisSettings.apiKey
        let model = SynthesisSettings.apiModel

        guard !apiKey.isEmpty else {
            lastError = "API key not configured. Go to Settings > AI to set it up."
            return nil
        }

        guard let url = URL(string: endpoint) else {
            lastError = "Invalid API endpoint URL."
            return nil
        }

        progress = "Preparing content for API..."

        // Build prompt
        var itemDescriptions: [String] = []
        for item in items {
            var desc = "Title: \(item.title)\nType: \(item.type.rawValue)"
            if let sourceURL = item.sourceURL { desc += "\nURL: \(sourceURL)" }
            if let content = item.content {
                desc += "\nContent: \(String(content.prefix(500)))"
            }
            let annotations = item.annotations.map { $0.content }.joined(separator: "\n- ")
            if !annotations.isEmpty {
                desc += "\nUser annotations:\n- \(annotations)"
            }
            let tags = item.tags.map(\.name).joined(separator: ", ")
            if !tags.isEmpty { desc += "\nTags: \(tags)" }
            itemDescriptions.append(desc)
        }

        let systemPrompt = """
        You are a knowledge synthesis assistant. The user has collected several items (articles, notes, videos, lectures) on a topic. \
        Generate a synthesis note in markdown that:
        1. Identifies key themes across the sources
        2. Highlights any contradictions between sources
        3. Notes open questions for further exploration
        4. References specific items by their titles
        Keep the synthesis concise but insightful. Use markdown headings, bullet points, and bold for emphasis.
        """

        let userPrompt = """
        Synthesize the following \(items.count) items from the collection "\(scopeTitle)":

        \(itemDescriptions.enumerated().map { "--- Item \($0.offset + 1) ---\n\($0.element)" }.joined(separator: "\n\n"))

        Generate a comprehensive synthesis note with sections for: Key Themes, Contradictions (if any), Progression/Connections, and Open Questions.
        """

        progress = "Calling API..."

        // Make API call
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.timeoutInterval = 60

        let body: [String: Any] = [
            "model": model,
            "messages": [
                ["role": "system", "content": systemPrompt],
                ["role": "user", "content": userPrompt]
            ],
            "max_tokens": 2000,
            "temperature": 0.7
        ]

        do {
            request.httpBody = try JSONSerialization.data(withJSONObject: body)
        } catch {
            lastError = "Failed to encode request: \(error.localizedDescription)"
            return nil
        }

        do {
            let (data, response) = try await URLSession.shared.data(for: request)

            guard let httpResponse = response as? HTTPURLResponse else {
                lastError = "Invalid response from API."
                return nil
            }

            guard httpResponse.statusCode == 200 else {
                let errorBody = String(data: data, encoding: .utf8) ?? "Unknown error"
                lastError = "API error (\(httpResponse.statusCode)): \(String(errorBody.prefix(200)))"
                return nil
            }

            guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let choices = json["choices"] as? [[String: Any]],
                  let first = choices.first,
                  let message = first["message"] as? [String: Any],
                  let content = message["content"] as? String else {
                lastError = "Failed to parse API response."
                return nil
            }

            var md = content
            md += "\n\n---\n*Generated via \(model) on \(Date().formatted(date: .abbreviated, time: .shortened))*\n"

            return SynthesisResult(
                markdownContent: md,
                sourceItemIDs: items.map(\.id),
                provider: .api
            )
        } catch {
            lastError = "Network error: \(error.localizedDescription)"
            return nil
        }
    }

    // MARK: - Helpers

    private func extractKeywords(from text: String) -> Set<String> {
        let stopWords: Set<String> = [
            "the", "a", "an", "is", "are", "was", "were", "be", "been", "being",
            "have", "has", "had", "do", "does", "did", "will", "would", "could",
            "should", "may", "might", "shall", "can", "need", "dare", "ought",
            "used", "to", "of", "in", "for", "on", "with", "at", "by", "from",
            "as", "into", "through", "during", "before", "after", "above", "below",
            "between", "out", "off", "over", "under", "again", "further", "then",
            "once", "here", "there", "when", "where", "why", "how", "all", "each",
            "every", "both", "few", "more", "most", "other", "some", "such", "no",
            "not", "only", "own", "same", "so", "than", "too", "very", "just",
            "because", "but", "and", "or", "if", "while", "that", "this", "these",
            "those", "it", "its", "they", "them", "their", "we", "our", "you",
            "your", "he", "him", "his", "she", "her", "about", "what", "which",
            "who", "whom", "also", "like", "get", "make", "new", "one", "two"
        ]

        let words = text.lowercased()
            .components(separatedBy: .alphanumerics.inverted)
            .filter { $0.count > 2 && !stopWords.contains($0) }

        // Count frequency
        var freq: [String: Int] = [:]
        for word in words {
            freq[word, default: 0] += 1
        }

        // Return top keywords by frequency
        return Set(
            freq.sorted { $0.value > $1.value }
                .prefix(20)
                .map(\.key)
        )
    }

    private func countTags(items: [Item]) -> [(tag: Tag, count: Int)] {
        var counts: [UUID: (tag: Tag, count: Int)] = [:]
        for item in items {
            for tag in item.tags {
                if let existing = counts[tag.id] {
                    counts[tag.id] = (existing.tag, existing.count + 1)
                } else {
                    counts[tag.id] = (tag, 1)
                }
            }
        }
        return counts.values.map { ($0.tag, $0.count) }
    }
}
